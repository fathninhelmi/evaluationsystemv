<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manager Home</title>
<link rel="stylesheet" href="./style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/appwrite@13.0.0/dist/iife/sdk.js"></script>
</head>
<body>

<header class="header">
    <a href="#" class="logo"><img src="logo.png" alt="logo"></a>
    <nav class="nav-desktop">
        <a href="/manager.html" class="nav-link active">Home</a>
        <a href="/spreadsheet.html" class="nav-link">Spreadsheet</a>
        <a href="/request.html" class="nav-link">Requested Form</a>
        <a href="#" id="logoutBtn" class="nav-link">Logout</a>
    </nav>
</header>

<div class="dashboard-container">
    <div class="dashtittle">
      <h1>Evaluation Dashboard</h1>
    </div>

    <div class="stats-bar">
      <div class="stats-card">
        <div class="stats-number" id="totalEvaluations">0</div>
        <div class="stats-label">Total Evaluations</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="completeEvaluations">0</div>
        <div class="stats-label">Complete</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="progressEvaluations">0</div>
        <div class="stats-label">In Progress</div>
      </div>
    </div>

    <div class="dashboard-grid">
      <div class="widget map-section">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìç</div>
            Evaluation Locations
          </div>
          <div class="filter-section">
            <select class="filter-select" id="locationFilter">
              <option value="all">All Locations</option>
              <option value="complete">Complete</option>
              <option value="progress">In Progress</option>
            </select>
            <label>From: <input type="date" id="startDate" onchange="applyFilters()"></label>
            <label>To: <input type="date" id="endDate" onchange="applyFilters()"></label>
          </div>
        </div>
        <div id="map"></div>
        <div style="padding: 10px; font-size: 12px; color: #666; border-top: 1px solid #e0e0e0;">
          <span id="mapStatus">Loading map data...</span>
        </div>
      </div>

      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìä</div>
            Product Categories
          </div>
        </div>
        <div class="chart-container">
          <canvas id="productChart"></canvas>
        </div>
        <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; justify-content: space-around; text-align: center;">
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #2ecc71;" id="totalWins">0</div>
              <div style="font-size: 14px; color: #666;">Total Wins</div>
            </div>
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="totalLoses">0</div>
              <div style="font-size: 14px; color: #666;">Total Loses</div>
            </div>
          </div>
          <div id="categoryBreakdown" style="margin-top: 15px; font-size: 12px; color: #666;"></div>
        </div>
      </div>

     <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìã</div>
            Recent Evaluations
          </div>
        </div>
        <div class="evaluation-list" id="evaluationList"></div>
      </div>
    </div>

      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìÖ</div>
            Monthly Progress
          </div>
        </div>
        <div class="chart-container">
          <canvas id="progressChart"></canvas>
        </div>
      </div>
</div>

<script>
const { Client, Account, Databases } = window.Appwrite;
const client = new Client();
client.setEndpoint("https://fra.cloud.appwrite.io/v1")
.setProject("68ddd7de00255d4f5c96");

const databases = new Databases(client);
const account = new Account(client);

const databaseId = "68ba8a9c001f17064e15";
const collectionId = "68ba918c0022d2b9a429";

const preEvalCollectionId = "68c7ced6001bd14d08f4";
const evalCollectionId    = "68bf9d5600257a20775a";
const postEvalCollectionId= "68bf9d62002b4f5f7f23";

let evaluationData = [];
let map;
let markers = [];
let locationCache = {}; // Cache geocoded locations in memory
let geocodeQueue = []; // Queue for geocoding requests
let isGeocoding = false;

async function checkSession() {
    try {
        const user = await account.get();
        console.log('Logged in as:', user.email);
        return user;
    } catch (err) {
        window.location.href = 'index.html';
        return null;
    }
}

document.getElementById("logoutBtn").addEventListener("click", async () => {
    try { await account.deleteSession('current'); window.location.href = "/index.html"; }
    catch { window.location.href = "/index.html"; }
});

async function getFormStatus(collectionId, formId) {
    try {
        const doc = await databases.getDocument(databaseId, collectionId, formId);
        return doc.status || 'draft';
    } catch { return 'draft'; }
}

function computeOverallStatus(pre, evalStatus, post) {
    const completedForms = [pre, evalStatus, post].filter(s => s === 'complete').length;
    const formsWithProgress = [pre, evalStatus, post].filter(s => s === 'complete' || s === 'progress').length;

    if (completedForms === 3) return 'complete';
    if (formsWithProgress > 0) return 'progress';
    return 'draft';
}

async function geocodeLocation(queryString) {
    // Check cache first
    if (locationCache[queryString]) {
        console.log(`‚úÖ Using cached location for: ${queryString}`);
        return locationCache[queryString];
    }

    try {
        // Add delay to respect Nominatim usage policy (1 request per second)
        await new Promise(resolve => setTimeout(resolve, 1100));
        
        console.log(`üîç Geocoding: ${queryString}`);
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(queryString)}&limit=1&addressdetails=1`);
        const data = await res.json();
        
        if (data && data.length > 0) {
            const result = {
                location: [parseFloat(data[0].lat), parseFloat(data[0].lon)],
                locationName: data[0].display_name || queryString
            };
            // Cache the result
            locationCache[queryString] = result;
            console.log(`‚úÖ Geocoded: ${queryString} -> [${result.location[0]}, ${result.location[1]}]`);
            return result;
        } else {
            console.warn(`‚ö†Ô∏è No results found for: ${queryString}`);
        }
    } catch (err) {
        console.error("‚ùå Geocoding failed for", queryString, err);
    }
    return null;
}

// Process geocoding queue one at a time
async function processGeocodeQueue() {
    if (isGeocoding || geocodeQueue.length === 0) return;
    
    isGeocoding = true;
    const updateStatus = document.getElementById('mapStatus');
    
    while (geocodeQueue.length > 0) {
        const item = geocodeQueue.shift();
        updateStatus.textContent = `Geocoding locations... ${geocodeQueue.length} remaining`;
        
        let geoResult = null;
        if (item.doc.customerLocation) {
            geoResult = await geocodeLocation(item.doc.customerLocation);
        }
        
        // Fallback to company name if primary location fails
        if (!geoResult && item.doc.customerCompany) {
            geoResult = await geocodeLocation(item.doc.customerCompany);
        }
        
        if (geoResult) {
            item.evaluation.location = geoResult.location;
            item.evaluation.locationName = geoResult.locationName;
        }
    }
    
    isGeocoding = false;
    updateStatus.textContent = `üìç Showing ${evaluationData.filter(e => e.location).length} of ${evaluationData.length} locations`;
    
    // Update map after all geocoding is complete
    if (map) {
        updateMapMarkers();
    }
}

async function loadEvaluations() {
    try {
        const response = await databases.listDocuments(databaseId, collectionId, [
            Appwrite.Query.limit(1000),
            Appwrite.Query.orderDesc('$createdAt')
        ]);

        evaluationData = [];
        geocodeQueue = [];

        console.log(`üìä Loading ${response.documents.length} evaluations...`);

        for (const doc of response.documents) {
            let preDoc, evalDoc, postDoc;
            let preStatus = 'draft', evalStatus = 'draft', postStatus = 'draft';
            let winLoseStatus = null;

            try { preDoc = await databases.getDocument(databaseId, preEvalCollectionId, doc.$id); preStatus = preDoc.status || 'draft'; } catch {}
            try { evalDoc = await databases.getDocument(databaseId, evalCollectionId, doc.$id); evalStatus = evalDoc.status || 'draft'; } catch {}
            try { 
                postDoc = await databases.getDocument(databaseId, postEvalCollectionId, doc.$id); 
                postStatus = postDoc.status || 'draft';
                winLoseStatus = postDoc.result || postDoc.winlose || postDoc.winLose || null;
            } catch {}

            const overallStatus = computeOverallStatus(preStatus, evalStatus, postStatus);

            let dates = [];
            if (preDoc?.completedAt) dates.push(new Date(preDoc.completedAt));
            if (evalDoc?.completedAt) dates.push(new Date(evalDoc.completedAt));
            if (postDoc?.completedAt) dates.push(new Date(postDoc.completedAt));

            const evalDate = dates.length > 0 ? new Date(Math.max(...dates)) : new Date(doc.$createdAt);
            let location = null;
            let locationName = doc.customerCompany || 'Unknown Location';

            const evaluation = {
                id: doc.$id,
                product: doc.prodname || 'Unknown Product',
                category: doc.productType || 'Other',
                staff: doc.username || doc.company || 'N/A',
                company: doc.company || 'N/A',
                customerCompany: doc.customerCompany || 'N/A',
                customerLocation: doc.customerLocation || 'N/A', 
                location: null,
                locationName,
                date: evalDate.toISOString().split('T')[0],
                timestamp: evalDate.toISOString(),
                pre_eval: preStatus,
                eval: evalStatus,
                post_eval: postStatus,
                status: overallStatus,
                winlose: winLoseStatus
            };

            evaluationData.push(evaluation);
            
            // Add to geocoding queue
            geocodeQueue.push({ doc, evaluation });
        }

        // Update dashboard immediately with data (without locations yet)
        updateStats();
        initCharts();
        populateEvaluationList();
        initMap();
        
        // Start geocoding in background
        processGeocodeQueue();

    } catch (err) {
        console.error("Error loading evaluations:", err);
        document.getElementById('evaluationList').innerHTML =
            '<div class="error-message">Failed to load evaluations. Refresh the page.</div>';
    }
}

function updateStats() {
    document.getElementById('totalEvaluations').textContent = evaluationData.length;
    document.getElementById('completeEvaluations').textContent = evaluationData.filter(e => e.status==='complete').length;
    document.getElementById('progressEvaluations').textContent = evaluationData.filter(e => e.status==='progress').length;
}

function initCharts() {
    const productStats = {};
    let totalWins = 0;
    let totalLoses = 0;

    evaluationData.forEach(item => {
        const cat = item.category;
        if (!productStats[cat]) {
            productStats[cat] = { total: 0, win: 0, lose: 0 };
        }
        productStats[cat].total++;
        
        if (item.winlose) {
            const status = item.winlose.toLowerCase();
            if (status === 'win') {
                productStats[cat].win++;
                totalWins++;
            } else if (status === 'lose' || status === 'loss') {
                productStats[cat].lose++;
                totalLoses++;
            }
        }
    });

    // Update win/lose totals
    document.getElementById('totalWins').textContent = totalWins;
    document.getElementById('totalLoses').textContent = totalLoses;

    // Update category breakdown
    const breakdownHTML = Object.entries(productStats)
        .map(([cat, stats]) => `${cat}: ${stats.win}W / ${stats.lose}L`)
        .join(' ‚Ä¢ ');
    document.getElementById('categoryBreakdown').innerHTML = breakdownHTML;

    const categories = Object.keys(productStats);
    const colors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

    // Product Chart (combined wins and losses)
    const productCtx = document.getElementById('productChart');
    if (!productCtx) {
        console.error('productChart canvas not found');
        return;
    }

    if (window.productChartInstance) window.productChartInstance.destroy();

    window.productChartInstance = new Chart(productCtx, {
        type: 'doughnut',
        data: { 
            labels: categories,
            datasets: [{ 
                label: 'Evaluations by Category',
                data: categories.map(cat => productStats[cat].total), 
                backgroundColor: colors
            }] 
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { 
                legend: { position: 'bottom', labels: { font: { size: 10 } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const cat = categories[context.dataIndex];
                            const total = productStats[cat].total;
                            const wins = productStats[cat].win;
                            const loses = productStats[cat].lose;
                            return `${cat}: ${total} (${wins}W/${loses}L)`;
                        }
                    }
                }
            } 
        }
    });

    // Monthly Progress Chart
    const monthlyData = getMonthlyProgressData();
    const progressCtx = document.getElementById('progressChart');
    if (!progressCtx) {
        console.error('progressChart canvas not found');
        return;
    }

    if (window.progressChartInstance) window.progressChartInstance.destroy();

    window.progressChartInstance = new Chart(progressCtx, {
        type: 'line',
        data: {
            labels: monthlyData.labels,
            datasets: [
                { 
                    label: 'Completed', 
                    data: monthlyData.completed, 
                    borderColor: '#2ecc71', 
                    backgroundColor: 'rgba(46,204,113,0.1)', 
                    fill: true, 
                    tension: 0.4, 
                    pointBackgroundColor: '#2ecc71', 
                    pointRadius: 5 
                },
                { 
                    label: 'Total', 
                    data: monthlyData.total, 
                    borderColor: '#3498db', 
                    backgroundColor: 'rgba(52,152,219,0.1)', 
                    fill: false, 
                    tension: 0.4, 
                    pointBackgroundColor: '#3498db', 
                    pointRadius: 5 
                }
            ]
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { legend: { position: 'top' } }, 
            scales: { y: { beginAtZero: true } } 
        }
    });
}

function getMonthlyProgressData() {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const currentYear = new Date().getFullYear();
    const stats = {};
    monthNames.forEach(m => stats[m]={total:0,completed:0});

    evaluationData.forEach(e=>{
        const date = new Date(e.date);
        if(date.getFullYear()===currentYear){
            const m = monthNames[date.getMonth()];
            stats[m].total++;
            if(e.status==='complete') stats[m].completed++;
        }
    });

    return { labels:monthNames, completed:monthNames.map(m=>stats[m].completed), total:monthNames.map(m=>stats[m].total) };
}

function populateEvaluationList() {
    const listContainer = document.getElementById('evaluationList');
    if (!listContainer) return;

    const recentEvaluations = evaluationData
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 8);

    if (recentEvaluations.length === 0) {
        listContainer.innerHTML = '<div class="empty-state">No evaluations found</div>';
        return;
    }

    listContainer.innerHTML = recentEvaluations.map(e => {
        const getStatusColor = (status) => {
            if (status === 'complete') return '#28a745';
            if (status === 'progress') return '#ffc107';
            return '#dc3545';
        };

        return `
            <div class="evaluation-item">
                <div class="evaluation-info">
                    <div class="evaluation-product">${e.product}</div>
                    <div class="evaluation-details">
                        üë§ ${e.staff} ‚Ä¢ üè¢ ${e.customerCompany} ‚Ä¢ üìç ${e.customerLocation} ‚Ä¢ üìÖ ${e.date}
                    </div>
                    <div class="form-progress" style="margin-top:4px;">
                        <small>
                            <span style="color: ${getStatusColor(e.pre_eval)}; font-weight: 500;">Pre-evaluation</span> | 
                            <span style="color: ${getStatusColor(e.eval)}; font-weight: 500;">Evaluation</span> | 
                            <span style="color: ${getStatusColor(e.post_eval)}; font-weight: 500;">Post-evaluation</span>
                        </small>
                    </div>
                </div>
                <div class="evaluation-status">
                    <span class="status-badge" style="background:${getStatusColor(e.status)};">
                        ${e.status === 'complete' ? '‚úÖ Complete' : e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                    </span>
                </div>
            </div>
        `;
    }).join('');
}

function initMap() {
    if(map) map.remove();
    map = L.map('map').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ 
        attribution:'¬© OpenStreetMap contributors', 
        maxZoom:18 
    }).addTo(map);
    
    updateMapMarkers();
}

function updateMapMarkers(){
    if(!map) return;
    
    markers.forEach(m=>map.removeLayer(m));
    markers = [];
    const data = getFilteredData();
    
    console.log(`üó∫Ô∏è Displaying ${data.length} evaluations on map`);
    let markersWithLocation = 0;
    
    data.forEach(e=>{
        if (e.location && Array.isArray(e.location) && e.location.length === 2) {
            const color = e.status==='complete'?'#28a745': e.status==='progress'?'#ffc107':'#dc3545';
            const icon = L.divIcon({
                className:'custom-marker', 
                html:`<div style="background:${color};width:26px;height:26px;border-radius:50%;border:3px solid white;box-shadow:0 3px 8px rgba(0,0,0,0.4);cursor:pointer;"></div>`, 
                iconSize:[26,26], 
                iconAnchor:[13,13]
            });
            const marker = L.marker(e.location,{icon}).addTo(map);
            marker.bindPopup(`
                <div style="min-width:220px; font-family: Arial, sans-serif;">
                    <div style="font-weight:bold; font-size:14px; margin-bottom:8px; color:#333;">${e.product}</div>
                    <div style="font-size:12px; color:#666; line-height:1.6;">
                        <div>üì¶ <strong>Category:</strong> ${e.category}</div>
                        <div>üë§ <strong>Staff:</strong> ${e.staff}</div>
                        <div>üè¢ <strong>Company:</strong> ${e.customerCompany}</div>
                        <div>üìç <strong>Location:</strong> ${e.customerLocation}</div>
                        <div>üìÖ <strong>Date:</strong> ${e.date}</div>
                    </div>
                    <div style="margin-top:8px; padding-top:8px; border-top:1px solid #eee;">
                        <span style="display:inline-block; padding:4px 8px; background:${color}; color:white; border-radius:4px; font-size:11px; font-weight:bold;">
                            ${e.status.toUpperCase()}
                        </span>
                    </div>
                </div>
            `);
            markers.push(marker);
            markersWithLocation++;
        } else {
            console.warn(`‚ö†Ô∏è No location for: ${e.customerCompany} - ${e.customerLocation}`);
        }
    });
    
    console.log(`‚úÖ ${markersWithLocation} markers displayed on map`);
    
    const updateStatus = document.getElementById('mapStatus');
    if (updateStatus) {
        updateStatus.textContent = `üìç Showing ${markersWithLocation} of ${data.length} locations on map`;
    }
    
    if(markers.length>0){ 
        const group=L.featureGroup(markers); 
        const bounds = group.getBounds();
        
        // Set max zoom level to prevent zooming too close when markers are nearby
        map.fitBounds(bounds, {
            padding: [50, 50],
            maxZoom: 11  // Prevent zooming closer than zoom level 11
        });
    } else { 
        console.warn('‚ö†Ô∏è No markers to display on map');
        map.setView([4.5, 101], 6); // Default to Malaysia view
    }
}

function getFilteredData() {
    const filter = document.getElementById('locationFilter')?.value || 'all';
    const start = document.getElementById("startDate").value?new Date(document.getElementById("startDate").value):null;
    const end = document.getElementById("endDate").value?new Date(document.getElementById("endDate").value):null;

    return evaluationData.filter(e=>{
        if(filter!=='all' && e.status!==filter) return false;
        const d = new Date(e.date);
        if(start && d<start) return false;
        if(end){ const eCopy=new Date(end); eCopy.setHours(23,59,59,999); if(d>eCopy) return false; }
        return true;
    });
}

function applyFilters(){ 
    updateMapMarkers(); 
}

function setupRealTimeUpdates(){
    client.subscribe(`databases.${databaseId}.collections.${collectionId}.documents`,()=>{
        console.log('üì° Real-time update received, reloading evaluations...');
        loadEvaluations();
    });
}

document.addEventListener('DOMContentLoaded', async ()=>{
    const user = await checkSession();
    if(user){
        await loadEvaluations();
        setupRealTimeUpdates();
        document.getElementById('locationFilter').addEventListener('change',updateMapMarkers);
        document.getElementById('startDate').addEventListener('change',applyFilters);
        document.getElementById('endDate').addEventListener('change',applyFilters);
    }
});
</script>

<footer class="footer">
<span>¬© 2025 ViTrox. All rights reserved.</span>
</footer>

</body>
</html>
