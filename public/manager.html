<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manager Home</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://cdn.jsdelivr.net/npm/appwrite@13.0.0/dist/iife/sdk.js"></script>
</head>
<body>

<header class="header">
    <a href="#" class="logo"><img src="logo.png" alt="logo"></a>
    <nav class="nav-desktop">
        <a href="/manager.html" class="nav-link active">Home</a>
        <a href="/spreadsheet.html" class="nav-link">Spreadsheet</a>
        <a href="/request.html" class="nav-link">Requested Form</a>
        <a href="library.html" class="nav-link">Library</a>
        <a href="#" id="logoutBtn" class="nav-link">Logout</a>
    </nav>
</header>

<div class="dashboard-container">
    <div class="dashtittle">
      <h1>Evaluation Dashboard</h1>
    </div>

    <div class="stats-bar">
      <div class="stats-card">
        <div class="stats-number" id="totalEvaluations">0</div>
        <div class="stats-label">Total Evaluations</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="completeEvaluations">0</div>
        <div class="stats-label">Complete</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="progressEvaluations">0</div>
        <div class="stats-label">In Progress</div>
      </div>
    </div>

    <div class="dashboard-grid">
      <div class="widget map-section">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìç</div>
            Evaluation Locations
          </div>
          <div class="filter-section">
            <select class="filter-select" id="locationFilter">
              <option value="all">All Locations</option>
              <option value="complete">Complete</option>
              <option value="progress">In Progress</option>
            </select>
            <label>From: <input type="date" id="startDate" onchange="applyFilters()"></label>
            <label>To: <input type="date" id="endDate" onchange="applyFilters()"></label>
          </div>
        </div>
        <div id="map"></div>
        <div class="map-status">
          <span id="mapStatus">Loading map data...</span>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-dot" style="background: #28a745;"></div>
              <span>Complete</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #ffc107;"></div>
              <span>In Progress</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #dc3545;"></div>
              <span>Draft</span>
            </div>
          </div>
        </div>
      </div>

        <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            Product Categories
          </div>
        </div>
        <div class="chart-container">
          <canvas id="productChart"></canvas>
        </div>
        <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; justify-content: space-around; text-align: center;">
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #2ecc71;" id="totalWins">0</div>
              <div style="font-size: 14px; color: #666;">Total Wins</div>
            </div>
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="totalLoses">0</div>
              <div style="font-size: 14px; color: #666;">Total Loses</div>
            </div>
          <div id="categoryBreakdown" style="margin-top: 15px; font-size: 13px; color: #333;"></div>
        <div class="widget-header" style="display:block; width:100%; margin-top:20px;">
          <div class="widget-title">
            Reasons for Loses
          </div>
        </div>
        </div>
        <div class="chart-container">
          <canvas id="loseReasonChart"></canvas>
        </div>
        <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
          <div id="loseReasonBreakdown" style="font-size: 13px; color: #333;"></div>
        </div>
      </div>
    </div>

     <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            Recent Evaluations
          </div>
        </div>
        <div class="evaluation-list" id="evaluationList"></div>
      </div>
    </div>

      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            Monthly Progress
          </div>
        </div>
        <div class="chart-container">
          <canvas id="progressChart"></canvas>
        </div>
      </div>
</div>
    
<script>
const { Client, Account, Databases } = window.Appwrite;
const client = new Client();
client.setEndpoint("https://fra.cloud.appwrite.io/v1")
.setProject("68ddd7de00255d4f5c96");

const databases = new Databases(client);
const account = new Account(client);

const databaseId = "68ba8a9c001f17064e15";
const collectionId = "68ba918c0022d2b9a429";

const preEvalCollectionId = "68c7ced6001bd14d08f4";
const evalCollectionId    = "68bf9d5600257a20775a";
const postEvalCollectionId= "68bf9d62002b4f5f7f23";

let evaluationData = [];
let map;
let markerClusterGroup;
let locationCache = {};

async function checkSession() {
    try {
        const user = await account.get();
        console.log('Logged in as:', user.email);
        return user;
    } catch (err) {
        window.location.href = 'index.html';
        return null;
    }
}

document.getElementById("logoutBtn").addEventListener("click", async () => {
    try { await account.deleteSession('current'); window.location.href = "/index.html"; }
    catch { window.location.href = "/index.html"; }
});

async function getFormStatus(collectionId, formId) {
    try {
        const doc = await databases.getDocument(databaseId, collectionId, formId);
        return doc.status || 'draft';
    } catch { return 'draft'; }
}

function computeOverallStatus(pre, evalStatus, post) {
    const completedForms = [pre, evalStatus, post].filter(s => s === 'complete').length;
    const formsWithProgress = [pre, evalStatus, post].filter(s => s === 'complete' || s === 'progress').length;

    if (completedForms === 3) return 'complete';
    if (formsWithProgress > 0) return 'progress';
    return 'draft';
}

async function geocodeLocation(companyName, locationString) {
    const cacheKey = `${companyName}|${locationString}`;
    
    if (locationCache[cacheKey]) {
        console.log(`‚úÖ Cache: ${cacheKey}`);
        return locationCache[cacheKey];
    }
    const searchQueries = [
        `${companyName}, ${locationString}`, 
        `${companyName}, ${locationString}, Malaysia`, 
        `${locationString}, Malaysia`, 
        locationString 
    ].filter(q => q && q.trim() && q !== ', ' && q !== ', Malaysia');

    for (const query of searchQueries) {
        try {
            await new Promise(resolve => setTimeout(resolve, 1100));
            
            console.log(`üîç Searching: "${query}"`);
            const res = await fetch(
                `https://nominatim.openstreetmap.org/search?` +
                `format=json&q=${encodeURIComponent(query)}` +
                `&limit=1&addressdetails=1`
            );
            
            const data = await res.json();
            
            if (data && data.length > 0) {
                const result = {
                    location: [parseFloat(data[0].lat), parseFloat(data[0].lon)],
                    locationName: data[0].display_name || query,
                    searchQuery: query
                };
                
                locationCache[cacheKey] = result;
                console.log(`‚úÖ FOUND: "${query}" -> [${result.location[0].toFixed(6)}, ${result.location[1].toFixed(6)}]`);
                console.log(`   Address: ${result.locationName}`);
                return result;
            } else {
                console.warn(`‚ö†Ô∏è No results for: "${query}"`);
            }
        } catch (err) {
            console.error(`‚ùå Error searching: "${query}"`, err);
        }
    }

    console.error(`‚ùå FAILED to geocode: Company="${companyName}", Location="${locationString}"`);
    return null;
}

async function loadEvaluations() {
    try {
        const response = await databases.listDocuments(databaseId, collectionId, [
            Appwrite.Query.limit(1000),
            Appwrite.Query.orderDesc('$createdAt')
        ]);

        evaluationData = [];
        console.log(`üìä Loading ${response.documents.length} evaluations...`);

        for (const doc of response.documents) {
            let preDoc, evalDoc, postDoc;
            let preStatus = 'draft', evalStatus = 'draft', postStatus = 'draft';
            let winLoseStatus = null;
            let loseReason = null;
            let otherReason = null;

            try { preDoc = await databases.getDocument(databaseId, preEvalCollectionId, doc.$id); preStatus = preDoc.status || 'draft'; } catch {}
            try { evalDoc = await databases.getDocument(databaseId, evalCollectionId, doc.$id); evalStatus = evalDoc.status || 'draft'; } catch {}
            try { 
                postDoc = await databases.getDocument(databaseId, postEvalCollectionId, doc.$id); 
                postStatus = postDoc.status || 'draft';
                winLoseStatus = postDoc.result || postDoc.winlose || postDoc.winLose || null;
                loseReason = postDoc.loseReason || null;
                otherReason = postDoc.otherReason || null;
            } catch {}

            const overallStatus = computeOverallStatus(preStatus, evalStatus, postStatus);

            let dates = [];
            if (preDoc?.completedAt) dates.push(new Date(preDoc.completedAt));
            if (evalDoc?.completedAt) dates.push(new Date(evalDoc.completedAt));
            if (postDoc?.completedAt) dates.push(new Date(postDoc.completedAt));

            const evalDate = dates.length > 0 ? new Date(Math.max(...dates)) : new Date(doc.$createdAt);

            evaluationData.push({
                id: doc.$id,
                product: doc.prodname || 'Unknown Product',
                category: doc.productType || 'Other',
                staff: doc.username || doc.company || 'N/A',
                company: doc.company || 'N/A',
                customerCompany: doc.customerCompany || 'N/A',
                customerLocation: doc.customerLocation || 'N/A',
                location: null,
                locationName: doc.customerCompany || 'Unknown Location',
                searchQuery: null,
                date: evalDate.toISOString().split('T')[0],
                timestamp: evalDate.toISOString(),
                pre_eval: preStatus,
                eval: evalStatus,
                post_eval: postStatus,
                status: overallStatus,
                winlose: winLoseStatus,
                loseReason: loseReason,
                otherReason: otherReason
            });
        }

        updateStats();
        initCharts();
        populateEvaluationList();
        initMap();
        geocodeLocations();

    } catch (err) {
        console.error("Error loading evaluations:", err);
        document.getElementById('evaluationList').innerHTML =
            '<div class="error-message">Failed to load evaluations. Refresh the page.</div>';
    }
}

async function geocodeLocations() {
    const updateStatus = document.getElementById('mapStatus');
    let processed = 0;
    let successCount = 0;
    const total = evaluationData.length;

    console.log(`\nüåç Starting geocoding for ${total} evaluations...\n`);

    for (const evaluation of evaluationData) {
        processed++;
        updateStatus.textContent = `Geocoding locations... ${processed}/${total} (${successCount} found)`;
        if (evaluation.location) {
            successCount++;
            continue;
        }

        const companyName = evaluation.customerCompany !== 'N/A' ? evaluation.customerCompany : '';
        const locationStr = evaluation.customerLocation !== 'N/A' ? evaluation.customerLocation : '';

        if (!companyName && !locationStr) {
            console.warn(`‚ö†Ô∏è Skipping: No company or location data for ${evaluation.product}`);
            continue;
        }

        console.log(`\n--- Evaluation ${processed}/${total} ---`);
        console.log(`Product: ${evaluation.product}`);
        console.log(`Company: ${companyName}`);
        console.log(`Location: ${locationStr}`);

        const geoResult = await geocodeLocation(companyName, locationStr);

        if (geoResult) {
            evaluation.location = geoResult.location;
            evaluation.locationName = geoResult.locationName;
            evaluation.searchQuery = geoResult.searchQuery;
            successCount++;
            console.log(`‚úÖ SUCCESS: Geocoded to [${geoResult.location[0].toFixed(6)}, ${geoResult.location[1].toFixed(6)}]`);
        } else {
            console.error(`‚ùå FAILED: Could not geocode "${companyName}, ${locationStr}"`);
        }
    }

    console.log(`\nüìä Geocoding complete: ${successCount}/${total} locations found\n`);
    updateStatus.textContent = `üìç Showing ${successCount} of ${total} locations on map`;
    updateMapMarkers();
}

function updateStats() {
    document.getElementById('totalEvaluations').textContent = evaluationData.length;
    document.getElementById('completeEvaluations').textContent = evaluationData.filter(e => e.status==='complete').length;
    document.getElementById('progressEvaluations').textContent = evaluationData.filter(e => e.status==='progress').length;
}

function initCharts() {
    const productStats = {};
    let totalWins = 0;
    let totalLoses = 0;
    const loseReasonStats = {};

    evaluationData.forEach(item => {
        const cat = item.category;
        if (!productStats[cat]) {
            productStats[cat] = { total: 0, win: 0, lose: 0, loseReasons: {} };
        }
        productStats[cat].total++;
        
        if (item.winlose) {
            const status = item.winlose.toLowerCase();
            if (status === 'win') {
                productStats[cat].win++;
                totalWins++;
            } else if (status === 'lose' || status === 'loss') {
                productStats[cat].lose++;
                totalLoses++;
                
                // Count lose reasons
                if (item.loseReason) {
                    const reason = item.loseReason === 'others' && item.otherReason 
                        ? item.otherReason 
                        : formatLoseReason(item.loseReason);
                    
                    // Global lose reasons
                    loseReasonStats[reason] = (loseReasonStats[reason] || 0) + 1;
                    
                    // Per-category lose reasons
                    if (!productStats[cat].loseReasons[reason]) {
                        productStats[cat].loseReasons[reason] = 0;
                    }
                    productStats[cat].loseReasons[reason]++;
                }
            }
        }
    });

    document.getElementById('totalWins').textContent = totalWins;
    document.getElementById('totalLoses').textContent = totalLoses;

    const breakdownHTML = `
    <div style="
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 4px;
        padding-left: 0;
        margin: 0;
        list-style: none;
        justify-items: center;
        text-align: center;
    ">
        ${Object.entries(productStats)
        .map(([cat, stats]) => `
            <div>${cat}: ${stats.win}W / ${stats.lose}L</div>
        `)
        .join('')}
    </div>`;
    document.getElementById('categoryBreakdown').innerHTML = breakdownHTML;

    const categories = Object.keys(productStats);
    const colors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

    const productCtx = document.getElementById('productChart');
    if (!productCtx) return;

    if (window.productChartInstance) window.productChartInstance.destroy();

    window.productChartInstance = new Chart(productCtx, {
        type: 'doughnut',
        data: { 
            labels: categories,
            datasets: [{ 
                label: 'Evaluations by Category',
                data: categories.map(cat => productStats[cat].total), 
                backgroundColor: colors
            }] 
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { 
                legend: { position: 'bottom', labels: { font: { size: 10 } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const cat = categories[context.dataIndex];
                            const total = productStats[cat].total;
                            const wins = productStats[cat].win;
                            const loses = productStats[cat].lose;
                            return `${cat}: ${total} (${wins}W/${loses}L)`;
                        }
                    }
                }
            } 
        }
    });

    // Create Lose Reason Chart - organized by product category
    const loseReasonCtx = document.getElementById('loseReasonChart');
    if (loseReasonCtx && Object.keys(loseReasonStats).length > 0) {
        if (window.loseReasonChartInstance) window.loseReasonChartInstance.destroy();

        const allReasons = Object.keys(loseReasonStats);
        const categoryColors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];
        
        // Create datasets for each product category
        const datasets = categories.map((cat, idx) => {
            const categoryData = allReasons.map(reason => 
                productStats[cat].loseReasons[reason] || 0
            );
            
            return {
                label: cat,
                data: categoryData,
                backgroundColor: categoryColors[idx % categoryColors.length],
                borderColor: categoryColors[idx % categoryColors.length],
                borderWidth: 1
            };
        });

        window.loseReasonChartInstance = new Chart(loseReasonCtx, {
            type: 'bar',
            data: {
                labels: allReasons,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: { font: { size: 10 } }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y} lose(s)`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    },
                    x: {
                        ticks: {
                            font: { size: 10 }
                        }
                    }
                }
            }
        });

        // Display breakdown text by category
        const breakdownText = categories.map(cat => {
            const categoryReasons = productStats[cat].loseReasons;
            if (Object.keys(categoryReasons).length === 0) return '';
            
            const reasonText = Object.entries(categoryReasons)
                .map(([reason, count]) => `${reason}: ${count}`)
                .join(', ');
            
            return `<div style="margin-bottom: 8px;"><strong>${cat}:</strong> ${reasonText}</div>`;
        }).filter(text => text).join('');
        
        document.getElementById('loseReasonBreakdown').innerHTML = breakdownText || '<div style="color: #999;">No lose reasons recorded</div>';
    } else if (loseReasonCtx) {
        document.getElementById('loseReasonBreakdown').innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No lose data available</div>';
    }

    const monthlyData = getMonthlyProgressData();
    const progressCtx = document.getElementById('progressChart');
    if (!progressCtx) return;

    if (window.progressChartInstance) window.progressChartInstance.destroy();

    window.progressChartInstance = new Chart(progressCtx, {
        type: 'line',
        data: {
            labels: monthlyData.labels,
            datasets: [
                { 
                    label: 'Completed', 
                    data: monthlyData.completed, 
                    borderColor: '#2ecc71', 
                    backgroundColor: 'rgba(46,204,113,0.1)', 
                    fill: true, 
                    tension: 0.4, 
                    pointBackgroundColor: '#2ecc71', 
                    pointRadius: 5 
                },
                { 
                    label: 'Total', 
                    data: monthlyData.total, 
                    borderColor: '#3498db', 
                    backgroundColor: 'rgba(52,152,219,0.1)', 
                    fill: false, 
                    tension: 0.4, 
                    pointBackgroundColor: '#3498db', 
                    pointRadius: 5 
                }
            ]
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { legend: { position: 'top' } }, 
            scales: { y: { beginAtZero: true } } 
        }
    });
}

function formatLoseReason(reason) {
    const reasonMap = {
        'expensive': 'Expensive',
        'better_product': 'Better Product',
        'advance_features': 'Advance Features',
        'others': 'Others'
    };
    return reasonMap[reason] || reason;
}

function getMonthlyProgressData() {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const currentYear = new Date().getFullYear();
    const stats = {};
    monthNames.forEach(m => stats[m]={total:0,completed:0});

    evaluationData.forEach(e=>{
        const date = new Date(e.date);
        if(date.getFullYear()===currentYear){
            const m = monthNames[date.getMonth()];
            stats[m].total++;
            if(e.status==='complete') stats[m].completed++;
        }
    });

    return { labels:monthNames, completed:monthNames.map(m=>stats[m].completed), total:monthNames.map(m=>stats[m].total) };
}

function populateEvaluationList() {
    const listContainer = document.getElementById('evaluationList');
    if (!listContainer) return;

    const recentEvaluations = evaluationData
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 8);

    if (recentEvaluations.length === 0) {
        listContainer.innerHTML = '<div class="empty-state">No evaluations found</div>';
        return;
    }

    listContainer.innerHTML = recentEvaluations.map(e => {
        const getStatusColor = (status) => {
            if (status === 'complete') return '#28a745';
            if (status === 'progress') return '#ffc107';
            return '#dc3545';
        };

        return `
            <div class="evaluation-item">
                <div class="evaluation-info">
                    <div class="evaluation-product">${e.product}</div>
                    <div class="evaluation-details">
                        üë§ ${e.staff} ‚Ä¢ üè¢ ${e.customerCompany} ‚Ä¢ üìç ${e.customerLocation} ‚Ä¢ üìÖ ${e.date}
                    </div>
                    <div class="form-progress" style="margin-top:4px;">
                        <small>
                            <span style="color: ${getStatusColor(e.pre_eval)}; font-weight: 500;">Pre-evaluation</span> | 
                            <span style="color: ${getStatusColor(e.eval)}; font-weight: 500;">Evaluation</span> | 
                            <span style="color: ${getStatusColor(e.post_eval)}; font-weight: 500;">Post-evaluation</span>
                        </small>
                    </div>
                </div>
                <div class="evaluation-status">
                    <span class="status-badge" style="background:${getStatusColor(e.status)};">
                        ${e.status === 'complete' ? '‚úÖ Complete' : e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                    </span>
                </div>
            </div>
        `;
    }).join('');
}

function initMap() {
    if(map) map.remove();
    
    map = L.map('map').setView([4.2105, 101.9758], 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);
    markerClusterGroup = L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });
    
    map.addLayer(markerClusterGroup);
}

function updateMapMarkers() {
    if (!map || !markerClusterGroup) return;

    markerClusterGroup.clearLayers();
    
    const data = getFilteredData();
    let displayedCount = 0;

    console.log(`\nüó∫Ô∏è Updating map with ${data.length} evaluations...`);

    data.forEach((e, index) => {
        if (e.location && Array.isArray(e.location) && e.location.length === 2) {
            const color = e.status === 'complete' ? '#28a745' : 
                         e.status === 'progress' ? '#ffc107' : '#dc3545';

            const icon = L.divIcon({
                className: 'custom-marker-icon',
                html: `<div style="
                    width: 32px;
                    height: 32px;
                    background: ${color};
                    border: 4px solid white;
                    border-radius: 50%;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 12px;
                    color: white;
                ">${index + 1}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });

            const marker = L.marker(e.location, { icon });
            
            const popupContent = `
                <div style="min-width: 260px; font-family: Arial, sans-serif;">
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 12px; color: #333; border-bottom: 3px solid ${color}; padding-bottom: 8px;">
                        ${e.product}
                    </div>
                    <div style="font-size: 13px; line-height: 2; color: #555;">
                        <div><strong>üì¶ Category:</strong> ${e.category}</div>
                        <div><strong>üë§ Staff:</strong> ${e.staff}</div>
                        <div><strong>üè¢ Company:</strong> ${e.customerCompany}</div>
                        <div><strong>üìç Location:</strong> ${e.customerLocation}</div>
                        <div><strong>üìÖ Date:</strong> ${e.date}</div>
                        ${e.searchQuery ? `<div style="font-size: 11px; color: #999; margin-top: 8px;"><em>Found via: "${e.searchQuery}"</em></div>` : ''}
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee; text-align: center;">
                        <span style="
                            display: inline-block;
                            padding: 8px 16px;
                            background: ${color};
                            color: white;
                            border-radius: 6px;
                            font-size: 13px;
                            font-weight: bold;
                            text-transform: uppercase;
                        ">
                            ${e.status === 'complete' ? '‚úÖ Complete' : 
                              e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                        </span>
                    </div>
                </div>
            `;

            marker.bindPopup(popupContent);
            markerClusterGroup.addLayer(marker);
            displayedCount++;

            console.log(`  ‚úì Marker ${index + 1}: ${e.customerCompany} at [${e.location[0].toFixed(4)}, ${e.location[1].toFixed(4)}]`);
        } else {
            console.warn(`  ‚úó No location: ${e.customerCompany} - ${e.customerLocation}`);
        }
    });
    if (displayedCount > 0) {
        const group = markerClusterGroup.getBounds();
        if (group.isValid()) {
            map.fitBounds(group, {
                padding: [50, 50],
                maxZoom: 13
            });
        }
    }

    console.log(`‚úÖ ${displayedCount} markers displayed on map\n`);
}

function getFilteredData() {
    const filter = document.getElementById('locationFilter')?.value || 'all';
    const start = document.getElementById("startDate").value ? new Date(document.getElementById("startDate").value) : null;
    const end = document.getElementById("endDate").value ? new Date(document.getElementById("endDate").value) : null;

    return evaluationData.filter(e => {
        if (filter !== 'all' && e.status !== filter) return false;
        const d = new Date(e.date);
        if (start && d < start) return false;
        if (end) {
            const eCopy = new Date(end);
            eCopy.setHours(23, 59, 59, 999);
            if (d > eCopy) return false;
        }
        return true;
    });
}

function applyFilters() {
    updateMapMarkers();
}

function setupRealTimeUpdates() {
    client.subscribe(`databases.${databaseId}.collections.${collectionId}.documents`, () => {
        console.log('üì° Real-time update received');
        loadEvaluations();
    });
}

document.addEventListener('DOMContentLoaded', async () => {
    const user = await checkSession();
    if (user) {
        await loadEvaluations();
        setupRealTimeUpdates();
        document.getElementById('locationFilter').addEventListener('change', updateMapMarkers);
        document.getElementById('startDate').addEventListener('change', applyFilters);
        document.getElementById('endDate').addEventListener('change', applyFilters);
    }
});
</script>

<footer class="footer">
<span>¬© 2025 ViTrox. All rights reserved.</span>
</footer>

</body>
</html>








