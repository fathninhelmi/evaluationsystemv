<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manager Home</title>
<link rel="stylesheet" href="./style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/appwrite@13.0.0/dist/iife/sdk.js"></script>
<style>
  #map {
    height: 500px;
    width: 100%;
    border-radius: 8px;
  }
  .map-status {
    padding: 10px;
    font-size: 12px;
    color: #666;
    border-top: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .legend {
    display: flex;
    gap: 15px;
    font-size: 11px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid white;
  }
</style>
</head>
<body>

<header class="header">
    <a href="#" class="logo"><img src="logo.png" alt="logo"></a>
    <nav class="nav-desktop">
        <a href="/manager.html" class="nav-link active">Home</a>
        <a href="/spreadsheet.html" class="nav-link">Spreadsheet</a>
        <a href="/request.html" class="nav-link">Requested Form</a>
        <a href="#" id="logoutBtn" class="nav-link">Logout</a>
    </nav>
</header>

<div class="dashboard-container">
    <div class="dashtittle">
      <h1>Evaluation Dashboard</h1>
    </div>

    <div class="stats-bar">
      <div class="stats-card">
        <div class="stats-number" id="totalEvaluations">0</div>
        <div class="stats-label">Total Evaluations</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="completeEvaluations">0</div>
        <div class="stats-label">Complete</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="progressEvaluations">0</div>
        <div class="stats-label">In Progress</div>
      </div>
    </div>

    <div class="dashboard-grid">
      <div class="widget map-section">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìç</div>
            Evaluation Locations
          </div>
          <div class="filter-section">
            <select class="filter-select" id="locationFilter">
              <option value="all">All Locations</option>
              <option value="complete">Complete</option>
              <option value="progress">In Progress</option>
            </select>
            <label>From: <input type="date" id="startDate" onchange="applyFilters()"></label>
            <label>To: <input type="date" id="endDate" onchange="applyFilters()"></label>
          </div>
        </div>
        <div id="map"></div>
        <div class="map-status">
          <span id="mapStatus">Loading map data...</span>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-dot" style="background: #28a745;"></div>
              <span>Complete</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #ffc107;"></div>
              <span>In Progress</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #dc3545;"></div>
              <span>Draft</span>
            </div>
          </div>
        </div>
      </div>

      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìä</div>
            Product Categories
          </div>
        </div>
        <div class="chart-container">
          <canvas id="productChart"></canvas>
        </div>
        <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; justify-content: space-around; text-align: center;">
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #2ecc71;" id="totalWins">0</div>
              <div style="font-size: 14px; color: #666;">Total Wins</div>
            </div>
            <div style="flex: 1;">
              <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="totalLoses">0</div>
              <div style="font-size: 14px; color: #666;">Total Loses</div>
            </div>
          </div>
          <div id="categoryBreakdown" style="margin-top: 15px; font-size: 12px; color: #666;"></div>
        </div>
      </div>

     <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìã</div>
            Recent Evaluations
          </div>
        </div>
        <div class="evaluation-list" id="evaluationList"></div>
      </div>
    </div>

      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìÖ</div>
            Monthly Progress
          </div>
        </div>
        <div class="chart-container">
          <canvas id="progressChart"></canvas>
        </div>
      </div>
</div>

<script>
const { Client, Account, Databases } = window.Appwrite;
const client = new Client();
client.setEndpoint("https://fra.cloud.appwrite.io/v1")
.setProject("68ddd7de00255d4f5c96");

const databases = new Databases(client);
const account = new Account(client);

const databaseId = "68ba8a9c001f17064e15";
const collectionId = "68ba918c0022d2b9a429";

const preEvalCollectionId = "68c7ced6001bd14d08f4";
const evalCollectionId    = "68bf9d5600257a20775a";
const postEvalCollectionId= "68bf9d62002b4f5f7f23";

let evaluationData = [];
let map;
let markers = [];
let locationCache = {};

async function checkSession() {
    try {
        const user = await account.get();
        console.log('Logged in as:', user.email);
        return user;
    } catch (err) {
        window.location.href = 'index.html';
        return null;
    }
}

document.getElementById("logoutBtn").addEventListener("click", async () => {
    try { await account.deleteSession('current'); window.location.href = "/index.html"; }
    catch { window.location.href = "/index.html"; }
});

async function getFormStatus(collectionId, formId) {
    try {
        const doc = await databases.getDocument(databaseId, collectionId, formId);
        return doc.status || 'draft';
    } catch { return 'draft'; }
}

function computeOverallStatus(pre, evalStatus, post) {
    const completedForms = [pre, evalStatus, post].filter(s => s === 'complete').length;
    const formsWithProgress = [pre, evalStatus, post].filter(s => s === 'complete' || s === 'progress').length;

    if (completedForms === 3) return 'complete';
    if (formsWithProgress > 0) return 'progress';
    return 'draft';
}

// Improved geocoding with multiple attempts and better formatting
async function geocodeLocation(queryString) {
    if (locationCache[queryString]) {
        console.log(`‚úÖ Cache: ${queryString}`);
        return locationCache[queryString];
    }

    // Clean and format the address
    const cleanAddress = queryString.trim();
    
    // Try multiple search strategies
    const searchQueries = [
        cleanAddress, // Original
        `${cleanAddress}, Malaysia`, // Add country if not present
        cleanAddress.split(',')[0] + ', Malaysia' // Just city/area + country
    ];

    for (const query of searchQueries) {
        try {
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            console.log(`üîç Searching: ${query}`);
            const res = await fetch(
                `https://nominatim.openstreetmap.org/search?` +
                `format=json&q=${encodeURIComponent(query)}` +
                `&limit=1&addressdetails=1&countrycodes=my,sg,cn,th,vn,id,ph`
            );
            
            const data = await res.json();
            
            if (data && data.length > 0) {
                const result = {
                    location: [parseFloat(data[0].lat), parseFloat(data[0].lon)],
                    locationName: data[0].display_name || queryString
                };
                
                locationCache[queryString] = result;
                console.log(`‚úÖ Found: ${query} -> [${result.location[0].toFixed(4)}, ${result.location[1].toFixed(4)}]`);
                return result;
            }
        } catch (err) {
            console.warn(`‚ö†Ô∏è Error searching: ${query}`, err);
        }
    }

    console.error(`‚ùå Not found: ${queryString}`);
    return null;
}

async function loadEvaluations() {
    try {
        const response = await databases.listDocuments(databaseId, collectionId, [
            Appwrite.Query.limit(1000),
            Appwrite.Query.orderDesc('$createdAt')
        ]);

        evaluationData = [];
        console.log(`üìä Loading ${response.documents.length} evaluations...`);

        for (const doc of response.documents) {
            let preDoc, evalDoc, postDoc;
            let preStatus = 'draft', evalStatus = 'draft', postStatus = 'draft';
            let winLoseStatus = null;

            try { preDoc = await databases.getDocument(databaseId, preEvalCollectionId, doc.$id); preStatus = preDoc.status || 'draft'; } catch {}
            try { evalDoc = await databases.getDocument(databaseId, evalCollectionId, doc.$id); evalStatus = evalDoc.status || 'draft'; } catch {}
            try { 
                postDoc = await databases.getDocument(databaseId, postEvalCollectionId, doc.$id); 
                postStatus = postDoc.status || 'draft';
                winLoseStatus = postDoc.result || postDoc.winlose || postDoc.winLose || null;
            } catch {}

            const overallStatus = computeOverallStatus(preStatus, evalStatus, postStatus);

            let dates = [];
            if (preDoc?.completedAt) dates.push(new Date(preDoc.completedAt));
            if (evalDoc?.completedAt) dates.push(new Date(evalDoc.completedAt));
            if (postDoc?.completedAt) dates.push(new Date(postDoc.completedAt));

            const evalDate = dates.length > 0 ? new Date(Math.max(...dates)) : new Date(doc.$createdAt);

            evaluationData.push({
                id: doc.$id,
                product: doc.prodname || 'Unknown Product',
                category: doc.productType || 'Other',
                staff: doc.username || doc.company || 'N/A',
                company: doc.company || 'N/A',
                customerCompany: doc.customerCompany || 'N/A',
                customerLocation: doc.customerLocation || 'N/A',
                location: null,
                locationName: doc.customerCompany || 'Unknown Location',
                date: evalDate.toISOString().split('T')[0],
                timestamp: evalDate.toISOString(),
                pre_eval: preStatus,
                eval: evalStatus,
                post_eval: postStatus,
                status: overallStatus,
                winlose: winLoseStatus
            });
        }

        updateStats();
        initCharts();
        populateEvaluationList();
        initMap();
        
        // Geocode locations in background
        geocodeLocations();

    } catch (err) {
        console.error("Error loading evaluations:", err);
        document.getElementById('evaluationList').innerHTML =
            '<div class="error-message">Failed to load evaluations. Refresh the page.</div>';
    }
}

async function geocodeLocations() {
    const updateStatus = document.getElementById('mapStatus');
    let processed = 0;
    const total = evaluationData.length;

    for (const evaluation of evaluationData) {
        processed++;
        updateStatus.textContent = `Geocoding locations... ${processed}/${total}`;

        // Skip if already has location
        if (evaluation.location) continue;

        // Try customerLocation first
        let geoResult = null;
        if (evaluation.customerLocation && evaluation.customerLocation !== 'N/A') {
            geoResult = await geocodeLocation(evaluation.customerLocation);
        }

        // Fallback to customerCompany
        if (!geoResult && evaluation.customerCompany && evaluation.customerCompany !== 'N/A') {
            geoResult = await geocodeLocation(evaluation.customerCompany);
        }

        if (geoResult) {
            evaluation.location = geoResult.location;
            evaluation.locationName = geoResult.locationName;
        }
    }

    const locatedCount = evaluationData.filter(e => e.location).length;
    updateStatus.textContent = `üìç Showing ${locatedCount} of ${total} locations`;
    updateMapMarkers();
}

function updateStats() {
    document.getElementById('totalEvaluations').textContent = evaluationData.length;
    document.getElementById('completeEvaluations').textContent = evaluationData.filter(e => e.status==='complete').length;
    document.getElementById('progressEvaluations').textContent = evaluationData.filter(e => e.status==='progress').length;
}

function initCharts() {
    const productStats = {};
    let totalWins = 0;
    let totalLoses = 0;

    evaluationData.forEach(item => {
        const cat = item.category;
        if (!productStats[cat]) {
            productStats[cat] = { total: 0, win: 0, lose: 0 };
        }
        productStats[cat].total++;
        
        if (item.winlose) {
            const status = item.winlose.toLowerCase();
            if (status === 'win') {
                productStats[cat].win++;
                totalWins++;
            } else if (status === 'lose' || status === 'loss') {
                productStats[cat].lose++;
                totalLoses++;
            }
        }
    });

    document.getElementById('totalWins').textContent = totalWins;
    document.getElementById('totalLoses').textContent = totalLoses;

    const breakdownHTML = Object.entries(productStats)
        .map(([cat, stats]) => `${cat}: ${stats.win}W / ${stats.lose}L`)
        .join(' ‚Ä¢ ');
    document.getElementById('categoryBreakdown').innerHTML = breakdownHTML;

    const categories = Object.keys(productStats);
    const colors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

    const productCtx = document.getElementById('productChart');
    if (!productCtx) return;

    if (window.productChartInstance) window.productChartInstance.destroy();

    window.productChartInstance = new Chart(productCtx, {
        type: 'doughnut',
        data: { 
            labels: categories,
            datasets: [{ 
                label: 'Evaluations by Category',
                data: categories.map(cat => productStats[cat].total), 
                backgroundColor: colors
            }] 
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { 
                legend: { position: 'bottom', labels: { font: { size: 10 } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const cat = categories[context.dataIndex];
                            const total = productStats[cat].total;
                            const wins = productStats[cat].win;
                            const loses = productStats[cat].lose;
                            return `${cat}: ${total} (${wins}W/${loses}L)`;
                        }
                    }
                }
            } 
        }
    });

    const monthlyData = getMonthlyProgressData();
    const progressCtx = document.getElementById('progressChart');
    if (!progressCtx) return;

    if (window.progressChartInstance) window.progressChartInstance.destroy();

    window.progressChartInstance = new Chart(progressCtx, {
        type: 'line',
        data: {
            labels: monthlyData.labels,
            datasets: [
                { 
                    label: 'Completed', 
                    data: monthlyData.completed, 
                    borderColor: '#2ecc71', 
                    backgroundColor: 'rgba(46,204,113,0.1)', 
                    fill: true, 
                    tension: 0.4, 
                    pointBackgroundColor: '#2ecc71', 
                    pointRadius: 5 
                },
                { 
                    label: 'Total', 
                    data: monthlyData.total, 
                    borderColor: '#3498db', 
                    backgroundColor: 'rgba(52,152,219,0.1)', 
                    fill: false, 
                    tension: 0.4, 
                    pointBackgroundColor: '#3498db', 
                    pointRadius: 5 
                }
            ]
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            plugins: { legend: { position: 'top' } }, 
            scales: { y: { beginAtZero: true } } 
        }
    });
}

function getMonthlyProgressData() {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const currentYear = new Date().getFullYear();
    const stats = {};
    monthNames.forEach(m => stats[m]={total:0,completed:0});

    evaluationData.forEach(e=>{
        const date = new Date(e.date);
        if(date.getFullYear()===currentYear){
            const m = monthNames[date.getMonth()];
            stats[m].total++;
            if(e.status==='complete') stats[m].completed++;
        }
    });

    return { labels:monthNames, completed:monthNames.map(m=>stats[m].completed), total:monthNames.map(m=>stats[m].total) };
}

function populateEvaluationList() {
    const listContainer = document.getElementById('evaluationList');
    if (!listContainer) return;

    const recentEvaluations = evaluationData
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 8);

    if (recentEvaluations.length === 0) {
        listContainer.innerHTML = '<div class="empty-state">No evaluations found</div>';
        return;
    }

    listContainer.innerHTML = recentEvaluations.map(e => {
        const getStatusColor = (status) => {
            if (status === 'complete') return '#28a745';
            if (status === 'progress') return '#ffc107';
            return '#dc3545';
        };

        return `
            <div class="evaluation-item">
                <div class="evaluation-info">
                    <div class="evaluation-product">${e.product}</div>
                    <div class="evaluation-details">
                        üë§ ${e.staff} ‚Ä¢ üè¢ ${e.customerCompany} ‚Ä¢ üìç ${e.customerLocation} ‚Ä¢ üìÖ ${e.date}
                    </div>
                    <div class="form-progress" style="margin-top:4px;">
                        <small>
                            <span style="color: ${getStatusColor(e.pre_eval)}; font-weight: 500;">Pre-evaluation</span> | 
                            <span style="color: ${getStatusColor(e.eval)}; font-weight: 500;">Evaluation</span> | 
                            <span style="color: ${getStatusColor(e.post_eval)}; font-weight: 500;">Post-evaluation</span>
                        </small>
                    </div>
                </div>
                <div class="evaluation-status">
                    <span class="status-badge" style="background:${getStatusColor(e.status)};">
                        ${e.status === 'complete' ? '‚úÖ Complete' : e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                    </span>
                </div>
            </div>
        `;
    }).join('');
}

function initMap() {
    if(map) map.remove();
    
    map = L.map('map').setView([4.2105, 101.9758], 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);
}

function updateMapMarkers() {
    if (!map) return;

    markers.forEach(m => map.removeLayer(m));
    markers = [];
    
    const data = getFilteredData();
    const bounds = L.latLngBounds([]);
    let hasMarkers = false;

    console.log(`üó∫Ô∏è Updating map with ${data.length} evaluations`);

    data.forEach(e => {
        if (e.location && Array.isArray(e.location) && e.location.length === 2) {
            const color = e.status === 'complete' ? '#28a745' : 
                         e.status === 'progress' ? '#ffc107' : '#dc3545';

            const icon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="
                    background: ${color};
                    width: 28px;
                    height: 28px;
                    border-radius: 50%;
                    border: 3px solid white;
                    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
                    cursor: pointer;
                    transition: transform 0.2s;
                "></div>`,
                iconSize: [28, 28],
                iconAnchor: [14, 14]
            });

            const marker = L.marker(e.location, { icon }).addTo(map);
            
            marker.bindPopup(`
                <div style="min-width: 240px; font-family: Arial, sans-serif;">
                    <div style="font-weight: bold; font-size: 15px; margin-bottom: 10px; color: #333; border-bottom: 2px solid ${color}; padding-bottom: 5px;">
                        ${e.product}
                    </div>
                    <div style="font-size: 13px; line-height: 1.8; color: #555;">
                        <div><strong>üì¶ Category:</strong> ${e.category}</div>
                        <div><strong>üë§ Staff:</strong> ${e.staff}</div>
                        <div><strong>üè¢ Company:</strong> ${e.customerCompany}</div>
                        <div><strong>üìç Location:</strong> ${e.customerLocation}</div>
                        <div><strong>üìÖ Date:</strong> ${e.date}</div>
                    </div>
                    <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; text-align: center;">
                        <span style="
                            display: inline-block;
                            padding: 6px 12px;
                            background: ${color};
                            color: white;
                            border-radius: 5px;
                            font-size: 12px;
                            font-weight: bold;
                            text-transform: uppercase;
                        ">
                            ${e.status === 'complete' ? '‚úÖ Complete' : 
                              e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                        </span>
                    </div>
                </div>
            `);

            // Add hover effect
            marker.on('mouseover', function() {
                this.getElement().querySelector('div').style.transform = 'scale(1.2)';
            });
            marker.on('mouseout', function() {
                this.getElement().querySelector('div').style.transform = 'scale(1)';
            });

            markers.push(marker);
            bounds.extend(e.location);
            hasMarkers = true;
        }
    });

    if (hasMarkers) {
        map.fitBounds(bounds, {
            padding: [50, 50],
            maxZoom: 12
        });
    } else {
        map.setView([4.2105, 101.9758], 6);
    }

    console.log(`‚úÖ ${markers.length} markers displayed`);
}

function getFilteredData() {
    const filter = document.getElementById('locationFilter')?.value || 'all';
    const start = document.getElementById("startDate").value ? new Date(document.getElementById("startDate").value) : null;
    const end = document.getElementById("endDate").value ? new Date(document.getElementById("endDate").value) : null;

    return evaluationData.filter(e => {
        if (filter !== 'all' && e.status !== filter) return false;
        const d = new Date(e.date);
        if (start && d < start) return false;
        if (end) {
            const eCopy = new Date(end);
            eCopy.setHours(23, 59, 59, 999);
            if (d > eCopy) return false;
        }
        return true;
    });
}

function applyFilters() {
    updateMapMarkers();
}

function setupRealTimeUpdates() {
    client.subscribe(`databases.${databaseId}.collections.${collectionId}.documents`, () => {
        console.log('üì° Real-time update received');
        loadEvaluations();
    });
}

document.addEventListener('DOMContentLoaded', async () => {
    const user = await checkSession();
    if (user) {
        await loadEvaluations();
        setupRealTimeUpdates();
        document.getElementById('locationFilter').addEventListener('change', updateMapMarkers);
        document.getElementById('startDate').addEventListener('change', applyFilters);
        document.getElementById('endDate').addEventListener('change', applyFilters);
    }
});
</script>

<footer class="footer">
<span>¬© 2025 ViTrox. All rights reserved.</span>
</footer>

</body>
</html>
