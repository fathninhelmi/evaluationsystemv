<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manager Home</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://cdn.jsdelivr.net/npm/appwrite@13.0.0/dist/iife/sdk.js"></script>
</head>
<body>

<header class="header">
    <a href="#" class="logo"><img src="logo.png" alt="logo"></a>
    <nav class="nav-desktop">
        <a href="/manager.html" class="nav-link active">Home</a>
        <a href="/spreadsheet.html" class="nav-link">Spreadsheet</a>
        <a href="/request.html" class="nav-link">Requested Form</a>
        <a href="library.html" class="nav-link">Library</a>
        <a href="#" id="logoutBtn" class="nav-link">Logout</a>
    </nav>
</header>

<div class="dashboard-container">
    <div class="dashtittle">
      <h1>Evaluation Dashboard</h1>
    </div>

    <div class="stats-bar">
      <div class="stats-card">
        <div class="stats-number" id="totalEvaluations">0</div>
        <div class="stats-label">Total Evaluations</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="completeEvaluations">0</div>
        <div class="stats-label">Complete</div>
      </div>
      <div class="stats-card">
        <div class="stats-number" id="progressEvaluations">0</div>
        <div class="stats-label">In Progress</div>
      </div>
    </div>

    <div class="dashboard-grid">
      <div class="widget map-section">
        <div class="widget-header">
          <div class="widget-title">
            <div class="widget-icon">üìç</div>
            Evaluation Locations
          </div>
          <div class="filter-section">
            <select class="filter-select" id="productFilter">
              <option value="all">All Solutions</option>
              <option value="SPI">SPI</option>
              <option value="AOI">AOI</option>
              <option value="AXI">AXI</option>
              <option value="ARV">ARV</option>
              <option value="XC">XC</option>
              <option value="XS">XS</option>
            </select>
            <select class="filter-select" id="locationFilter">
              <option value="all">All Locations</option>
              <option value="complete">Complete</option>
              <option value="progress">In Progress</option>
            </select>
            <label>From: <input type="date" id="startDate" onchange="applyFilters()"></label>
            <label>To: <input type="date" id="endDate" onchange="applyFilters()"></label>
          </div>
        </div>
        <div id="map"></div>
        <div class="map-status">
          <span id="mapStatus">Loading map data...</span>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-dot" style="background: #28a745;"></div>
              <span>Complete</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #ffc107;"></div>
              <span>In Progress</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #dc3545;"></div>
              <span>Draft</span>
            </div>
          </div>
        </div>
      </div>

 <div class="widget">
  <div class="widget-header">
    <div class="widget-title">
      Product Categories
    </div>
  </div>

  <div class="chart-container">
    <canvas id="productChart"></canvas>
  </div>

  <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
    <div style="display: flex; justify-content: space-around; text-align: center;">
      <div style="flex: 1;">
        <div style="font-size: 24px; font-weight: bold; color: #2ecc71;" id="totalWins">0</div>
        <div style="font-size: 14px; color: #666;">Total Wins</div>
      </div>
      <div style="flex: 1;">
        <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="totalLoses">0</div>
        <div style="font-size: 14px; color: #666;">Total Loses</div>
      </div>
    </div>
    <div id="categoryBreakdown" style="margin-top: 15px; font-size: 13px; color: #333;"></div>
  </div>
</div>

    <div class="widget">
       <div class="widget-header">
         <div class="widget-title">
           Recent Evaluations
          </div>
        </div>
        <div class="evaluation-list" id="evaluationList"></div>
      </div>
    </div>
    
 <div class="widget">
 <div class="widget-header">
    <div class="widget-title">
      Reasons for Wins
    </div>
  </div>

  <div class="chart-container">
    <canvas id="winReasonChart"></canvas>
  </div>

  <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
    <div id="winReasonBreakdown" style="font-size: 13px; color: #333;"></div>
  </div>

 <div class="widget-header" style="margin-top: 20px;">
    <div class="widget-title">
      Reasons for Loses
    </div>
  </div>

  <div class="chart-container">
    <canvas id="loseReasonChart"></canvas>
  </div>

  <div style="padding: 15px; border-top: 1px solid #e0e0e0;">
    <div id="loseReasonBreakdown" style="font-size: 13px; color: #333;"></div>
  </div>
 </div>
    
      <div class="widget">
        <div class="widget-header">
          <div class="widget-title">
            Monthly Progress
          </div>
        </div>
        <div class="chart-container">
          <canvas id="progressChart"></canvas>
        </div>
      </div>
</div>
    
<script>
const { Client, Account, Databases } = window.Appwrite;
const client = new Client();
client.setEndpoint("https://fra.cloud.appwrite.io/v1")
.setProject("68ddd7de00255d4f5c96");

const databases = new Databases(client);
const account = new Account(client);

const databaseId = "68ba8a9c001f17064e15";
const collectionId = "68ba918c0022d2b9a429";

const preEvalCollectionId = "68c7ced6001bd14d08f4";
const evalCollectionId    = "68bf9d5600257a20775a";
const postEvalCollectionId= "68bf9d62002b4f5f7f23";

let evaluationData = [];
let map;
let markerClusterGroup;
let locationCache = {};

async function checkSession() {
    try {
        const user = await account.get();
        console.log('Logged in as:', user.email);
        return user;
    } catch (err) {
        window.location.href = 'index.html';
        return null;
    }
}

document.getElementById("logoutBtn").addEventListener("click", async () => {
    try { await account.deleteSession('current'); window.location.href = "/index.html"; }
    catch { window.location.href = "/index.html"; }
});

async function getFormStatus(collectionId, formId) {
    try {
        const doc = await databases.getDocument(databaseId, collectionId, formId);
        return doc.status || 'draft';
    } catch { return 'draft'; }
}

function computeOverallStatus(pre, evalStatus, post) {
    const completedForms = [pre, evalStatus, post].filter(s => s === 'complete').length;
    const formsWithProgress = [pre, evalStatus, post].filter(s => s === 'complete' || s === 'progress').length;

    if (completedForms === 3) return 'complete';
    if (formsWithProgress > 0) return 'progress';
    return 'draft';
}

async function geocodeLocation(companyName, locationString) {
    const cacheKey = `${companyName}|${locationString}`;
    
    if (locationCache[cacheKey]) {
        console.log(`‚úÖ Cache: ${cacheKey}`);
        return locationCache[cacheKey];
    }
    const searchQueries = [
        `${companyName}, ${locationString}`, 
        `${companyName}, ${locationString}, Malaysia`, 
        `${locationString}, Malaysia`, 
        locationString 
    ].filter(q => q && q.trim() && q !== ', ' && q !== ', Malaysia');

    for (const query of searchQueries) {
        try {
            await new Promise(resolve => setTimeout(resolve, 1100));
            
            console.log(`üîç Searching: "${query}"`);
            const res = await fetch(
                `https://nominatim.openstreetmap.org/search?` +
                `format=json&q=${encodeURIComponent(query)}` +
                `&limit=1&addressdetails=1`
            );
            
            const data = await res.json();
            
            if (data && data.length > 0) {
                const result = {
                    location: [parseFloat(data[0].lat), parseFloat(data[0].lon)],
                    locationName: data[0].display_name || query,
                    searchQuery: query
                };
                
                locationCache[cacheKey] = result;
                console.log(`‚úÖ FOUND: "${query}" -> [${result.location[0].toFixed(6)}, ${result.location[1].toFixed(6)}]`);
                console.log(`   Address: ${result.locationName}`);
                return result;
            } else {
                console.warn(`‚ö†Ô∏è No results for: "${query}"`);
            }
        } catch (err) {
            console.error(`‚ùå Error searching: "${query}"`, err);
        }
    }

    console.error(`‚ùå FAILED to geocode: Company="${companyName}", Location="${locationString}"`);
    return null;
}

async function loadEvaluations() {
    try {
        const response = await databases.listDocuments(databaseId, collectionId, [
            Appwrite.Query.limit(1000),
            Appwrite.Query.orderDesc('$createdAt')
        ]);

        evaluationData = [];
        console.log(`üìä Loading ${response.documents.length} evaluations...`);

        for (const doc of response.documents) {
            let preDoc, evalDoc, postDoc;
            let preStatus = 'draft', evalStatus = 'draft', postStatus = 'draft';
            let winLoseStatus = null;
            let loseReason = null;
            let otherloseReason = null;
            let winReason = null;
            let otherwinReason = null;

            try { preDoc = await databases.getDocument(databaseId, preEvalCollectionId, doc.$id); preStatus = preDoc.status || 'draft'; } catch {}
            try { evalDoc = await databases.getDocument(databaseId, evalCollectionId, doc.$id); evalStatus = evalDoc.status || 'draft'; } catch {}
            try { 
                postDoc = await databases.getDocument(databaseId, postEvalCollectionId, doc.$id); 
                postStatus = postDoc.status || 'draft';
                winLoseStatus = postDoc.result || postDoc.winlose || postDoc.winLose || null;
                loseReason = postDoc.loseReason || null;
                otherloseReason = postDoc.otherloseReason || postDoc.otherloseReason || null;
                winReason = postDoc.winReason || null;
                otherwinReason = postDoc.otherwinReason || postDoc.otherwinReason || null;
            } catch {}

            const overallStatus = computeOverallStatus(preStatus, evalStatus, postStatus);

            let dates = [];
            if (preDoc?.completedAt) dates.push(new Date(preDoc.completedAt));
            if (evalDoc?.completedAt) dates.push(new Date(evalDoc.completedAt));
            if (postDoc?.completedAt) dates.push(new Date(postDoc.completedAt));

            const evalDate = dates.length > 0 ? new Date(Math.max(...dates)) : new Date(doc.$createdAt);

            evaluationData.push({
                id: doc.$id,
                product: doc.prodname || 'Unknown Product',
                category: doc.productType || 'Other',
                staff: doc.username || doc.company || 'N/A',
                company: doc.company || 'N/A',
                customerCompany: doc.customerCompany || 'N/A',
                customerLocation: doc.customerLocation || 'N/A',
                location: null,
                locationName: doc.customerCompany || 'Unknown Location',
                searchQuery: null,
                date: evalDate.toISOString().split('T')[0],
                timestamp: evalDate.toISOString(),
                pre_eval: preStatus,
                eval: evalStatus,
                post_eval: postStatus,
                status: overallStatus,
                winlose: winLoseStatus,
                loseReason: loseReason,
                otherloseReason: otherloseReason,
                winReason: winReason,
                otherwinReason: otherwinReason
            });
        }

        updateStats();
        initCharts();
        populateEvaluationList();
        initMap();
        geocodeLocations();

    } catch (err) {
        console.error("Error loading evaluations:", err);
        document.getElementById('evaluationList').innerHTML =
            '<div class="error-message">Failed to load evaluations. Refresh the page.</div>';
    }
}

async function geocodeLocations() {
    const updateStatus = document.getElementById('mapStatus');
    let processed = 0;
    let successCount = 0;
    const total = evaluationData.length;

    console.log(`\nüåç Starting geocoding for ${total} evaluations...\n`);

    for (const evaluation of evaluationData) {
        processed++;
        updateStatus.textContent = `Geocoding locations... ${processed}/${total} (${successCount} found)`;
        if (evaluation.location) {
            successCount++;
            continue;
        }

        const companyName = evaluation.customerCompany !== 'N/A' ? evaluation.customerCompany : '';
        const locationStr = evaluation.customerLocation !== 'N/A' ? evaluation.customerLocation : '';

        if (!companyName && !locationStr) {
            console.warn(`‚ö†Ô∏è Skipping: No company or location data for ${evaluation.product}`);
            continue;
        }

        console.log(`\n--- Evaluation ${processed}/${total} ---`);
        console.log(`Product: ${evaluation.product}`);
        console.log(`Company: ${companyName}`);
        console.log(`Location: ${locationStr}`);

        const geoResult = await geocodeLocation(companyName, locationStr);

        if (geoResult) {
            evaluation.location = geoResult.location;
            evaluation.locationName = geoResult.locationName;
            evaluation.searchQuery = geoResult.searchQuery;
            successCount++;
            console.log(`‚úÖ SUCCESS: Geocoded to [${geoResult.location[0].toFixed(6)}, ${geoResult.location[1].toFixed(6)}]`);
        } else {
            console.error(`‚ùå FAILED: Could not geocode "${companyName}, ${locationStr}"`);
        }
    }

    console.log(`\nüìä Geocoding complete: ${successCount}/${total} locations found\n`);
    updateStatus.textContent = `üìç Showing ${successCount} of ${total} locations on map`;
    updateMapMarkers();
}

function updateStats() {
    document.getElementById('totalEvaluations').textContent = evaluationData.length;
    document.getElementById('completeEvaluations').textContent = evaluationData.filter(e => e.status==='complete').length;
    document.getElementById('progressEvaluations').textContent = evaluationData.filter(e => e.status==='progress').length;
}

function initCharts() {
    const productStats = {};
    let totalWins = 0;
    let totalLoses = 0;
    const loseReasonStats = {};
    const winReasonStats = {};

    evaluationData.forEach(item => {
        const cat = item.category || 'Other';
        if (!productStats[cat]) {
            productStats[cat] = { total: 0, win: 0, lose: 0, loseReason: {}, winReason: {} };
        }
        productStats[cat].total++;

        if (item.winlose) {
            const status = item.winlose.toLowerCase();
            if (status === 'win') {
                productStats[cat].win++;
                totalWins++;

                // Handle win reasons as array
                if (Array.isArray(item.winReason)) {
                    item.winReason.forEach(reasonValue => {
                        const reason = reasonValue === 'others' ? 'Others' : formatwinReason(reasonValue);
                        
                        winReasonStats[reason] = (winReasonStats[reason] || 0) + 1;
                        
                        if (!productStats[cat].winReason[reason]) {
                            productStats[cat].winReason[reason] = 0;
                        }
                        productStats[cat].winReason[reason]++;
                    });
                }
            } else if (status === 'lose' || status === 'loss') {
                productStats[cat].lose++;
                totalLoses++;

                // Handle lose reasons as array
                if (Array.isArray(item.loseReason)) {
                    item.loseReason.forEach(reasonValue => {
                        const reason = reasonValue === 'others' ? 'Others' : formatLoseReason(reasonValue);
                        
                        loseReasonStats[reason] = (loseReasonStats[reason] || 0) + 1;
                        
                        if (!productStats[cat].loseReason[reason]) {
                            productStats[cat].loseReason[reason] = 0;
                        }
                        productStats[cat].loseReason[reason]++;
                    });
                }
            }
        } }); 

    // Update total wins/loses
    document.getElementById('totalWins').textContent = totalWins;
    document.getElementById('totalLoses').textContent = totalLoses;

    const categories = Object.keys(productStats);
    const colors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

    // Build category breakdown table
    const breakdown = categories.map(cat => ({
        category: cat,
        wins: productStats[cat].win,
        loses: productStats[cat].lose
    }));

    let html = `
      <table style="width:100%; border-collapse: collapse; font-size: 13px;">
        <thead>
          <tr style="background: #f7f7f7; text-align: left;">
            <th style="padding: 8px; border-bottom: 1px solid #ddd;">Category</th>
            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align:center;">Wins</th>
            <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align:center;">Loses</th>
          </tr>
        </thead>
        <tbody>
    `;

    breakdown.forEach(item => {
        html += `
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">${item.category}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align:center; color:#2ecc71; font-weight:600;">${item.wins}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align:center; color:#e74c3c; font-weight:600;">${item.loses}</td>
          </tr>
        `;
    });

    html += `
        </tbody>
      </table>
    `;

    document.getElementById("categoryBreakdown").innerHTML = html;
    
    // Product chart
    const productCtx = document.getElementById('productChart');
    if (productCtx) {
        if (window.productChartInstance) window.productChartInstance.destroy();
        window.productChartInstance = new Chart(productCtx, {
            type: 'doughnut',
            data: { 
                labels: categories,
                datasets: [{ 
                    label: 'Evaluations by Category',
                    data: categories.map(cat => productStats[cat].total), 
                    backgroundColor: colors
                }] 
            },
            options: { 
                responsive: true, 
                maintainAspectRatio: false, 
                plugins: { 
                    legend: { position: 'bottom', labels: { font: { size: 10 } } },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const cat = categories[context.dataIndex];
                                const total = productStats[cat].total;
                                const wins = productStats[cat].win;
                                const loses = productStats[cat].lose;
                                return `${cat}: ${total} (${wins}W/${loses}L)`;
                            }
                        }
                    }
                } 
            }
        });
    }

// Win Reason Chart
    const winReasonCtx = document.getElementById('winReasonChart');
    if (winReasonCtx && Object.keys(winReasonStats).length > 0) {
        if (window.winReasonChartInstance) window.winReasonChartInstance.destroy();

        // Define the exact order of reasons we want on X-axis
        const allwinReason = ['Good value of money', 'Best Product', 'Advanced features'];
        const categoryColors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

        const winDatasets = categories.map((cat, idx) => {
            const categoryData = allwinReason.map(reason =>
                productStats[cat].winReason[reason] || 0
            );
            return {
                label: cat,
                data: categoryData,
                backgroundColor: categoryColors[idx % categoryColors.length],
                borderColor: categoryColors[idx % categoryColors.length],
                borderWidth: 1
            };
        });

        window.winReasonChartInstance = new Chart(winReasonCtx, {
            type: 'bar',
            data: {
                labels: allwinReason,
                datasets: winDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top', labels: { font: { size: 10 } } },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y} win(s)`;
                            }
                        }
                    }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        ticks: { stepSize: 1 },
                        stacked: true
                    },
                    x: { 
                        ticks: { font: { size: 10 } },
                        stacked: true
                    }
                }
            }
        });

        // Build "Others" breakdown table
        const othersData = [];
        categories.forEach(cat => {
            const otherwinReason = evaluationData
                .filter(item => {
                    // Check if winReason is an array and includes 'others'
                    if (Array.isArray(item.winReason)) {
                        return item.category === cat && item.winReason.includes('others') && item.otherwinReason;
                    }
                    return false;
                })
                .map(item => item.otherwinReason);
        
            if (otherwinReason.length > 0) {
                const reasonCounts = {};
                otherwinReason.forEach(reason => {
                    reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;
                });
                
                Object.entries(reasonCounts).forEach(([reason, count]) => {
                    othersData.push({ category: cat, reason, count });
                });
            }
        });

        if (othersData.length > 0) {
            let tableHtml = `
                <div style="margin-top: 15px;">
                    <strong style="font-size: 14px; color: #333;">Other Win Reasons (User-Entered):</strong>
                    <table style="width:100%; border-collapse: collapse; font-size: 12px; margin-top: 8px;">
                        <thead>
                            <tr style="background: #f7f7f7; text-align: left;">
                                <th style="padding: 6px 8px; border: 1px solid #ddd;">Category</th>
                                <th style="padding: 6px 8px; border: 1px solid #ddd;">Reason</th>
                                <th style="padding: 6px 8px; border: 1px solid #ddd; text-align:center;">Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            othersData.forEach(item => {
                tableHtml += `
                    <tr>
                        <td style="padding: 6px 8px; border: 1px solid #eee;">${item.category}</td>
                        <td style="padding: 6px 8px; border: 1px solid #eee;">${item.reason}</td>
                        <td style="padding: 6px 8px; border: 1px solid #eee; text-align:center; font-weight:600;">${item.count}</td>
                    </tr>
                `;
            });
            
            tableHtml += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('winReasonBreakdown').innerHTML = tableHtml;
        } else {
            document.getElementById('winReasonBreakdown').innerHTML = '<div style="color: #999;">No user-entered win reasons recorded</div>';
        }
    } else {
        document.getElementById('winReasonBreakdown').innerHTML = '<div style="color: #999;">No win reasons recorded yet</div>';
    }

   // Lose Reason Chart
    const loseReasonCtx = document.getElementById('loseReasonChart');
    if (loseReasonCtx && Object.keys(loseReasonStats).length > 0) {
        if (window.loseReasonChartInstance) window.loseReasonChartInstance.destroy();

        // Define the exact order of reasons we want on X-axis
        const allReason = ['Expensive', 'Better Product', 'Advance Features', 'Others'];
        const categoryColors = ['#3498db','#e74c3c','#f39c12','#2ecc71','#9b59b6','#1abc9c','#e67e22'];

        const datasets = categories.map((cat, idx) => {
            const categoryData = allReason.map(reason =>
                productStats[cat].loseReason[reason] || 0
            );
            return {
                label: cat,
                data: categoryData,
                backgroundColor: categoryColors[idx % categoryColors.length],
                borderColor: categoryColors[idx % categoryColors.length],
                borderWidth: 1
            };
        });

        window.loseReasonChartInstance = new Chart(loseReasonCtx, {
            type: 'bar',
            data: {
                labels: allReason,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top', labels: { font: { size: 10 } } },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y} lose(s)`;
                            }
                        }
                    }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        ticks: { stepSize: 1 },
                        stacked: true
                    },
                    x: { 
                        ticks: { font: { size: 10 } },
                        stacked: true
                    }
                }
            }
        });

        // Build "Others" breakdown table
        const othersData = [];
        categories.forEach(cat => {
            const otherloseReason = evaluationData
                .filter(item => {
                    // Check if loseReason is an array and includes 'others'
                    if (Array.isArray(item.loseReason)) {
                        return item.category === cat && item.loseReason.includes('others') && item.otherloseReason;
                    }
                    return false;
                })
                .map(item => item.otherloseReason);
        
            if (otherloseReason.length > 0) {
                const reasonCounts = {};
                otherloseReason.forEach(reason => {
                    reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;
                });
                
                Object.entries(reasonCounts).forEach(([reason, count]) => {
                    othersData.push({ category: cat, reason, count });
                });
            }
        });

        if (othersData.length > 0) {
            let tableHtml = `
                <div style="margin-top: 15px;">
                    <strong style="font-size: 14px; color: #333;">Other Lose Reasons (User-Entered):</strong>
                    <table style="width:100%; border-collapse: collapse; font-size: 12px; margin-top: 8px;">
                        <thead>
                            <tr style="background: #f7f7f7; text-align: left;">
                                <th style="padding: 6px 8px; border: 1px solid #ddd;">Category</th>
                                <th style="padding: 6px 8px; border: 1px solid #ddd;">Reason</th>
                                <th style="padding: 6px 8px; border: 1px solid #ddd; text-align:center;">Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            othersData.forEach(item => {
                tableHtml += `
                    <tr>
                        <td style="padding: 6px 8px; border: 1px solid #eee;">${item.category}</td>
                        <td style="padding: 6px 8px; border: 1px solid #eee;">${item.reason}</td>
                        <td style="padding: 6px 8px; border: 1px solid #eee; text-align:center; font-weight:600;">${item.count}</td>
                    </tr>
                `;
            });
            
            tableHtml += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('loseReasonBreakdown').innerHTML = tableHtml;
        } else {
            document.getElementById('loseReasonBreakdown').innerHTML = '<div style="color: #999;">No user-entered lose reasons recorded</div>';
        }
    } else {
        document.getElementById('loseReasonBreakdown').innerHTML = '<div style="color: #999;">No lose reasons recorded yet</div>';
    }
    
    // Monthly Progress Chart
    const monthlyData = getMonthlyProgressData();
    const progressCtx = document.getElementById('progressChart');
    if (progressCtx) {
        if (window.progressChartInstance) window.progressChartInstance.destroy();
        window.progressChartInstance = new Chart(progressCtx, {
            type: 'line',
            data: {
                labels: monthlyData.labels,
                datasets: [
                    { 
                        label: 'Completed', 
                        data: monthlyData.completed, 
                        borderColor: '#2ecc71', 
                        backgroundColor: 'rgba(46,204,113,0.1)', 
                        fill: true, 
                        tension: 0.4, 
                        pointBackgroundColor: '#2ecc71', 
                        pointRadius: 5 
                    },
                    { 
                        label: 'Total', 
                        data: monthlyData.total, 
                        borderColor: '#3498db', 
                        backgroundColor: 'rgba(52,152,219,0.1)', 
                        fill: false, 
                        tension: 0.4, 
                        pointBackgroundColor: '#3498db', 
                        pointRadius: 5 
                    }
                ]
            },
            options: { 
                responsive: true, 
                maintainAspectRatio: false, 
                plugins: { legend: { position: 'top' } }, 
                scales: { y: { beginAtZero: true } } 
            }
        });
    }
}
function formatLoseReason(reason) {
    const reasonMap = {
        'expensive': 'Expensive',
        'better_product': 'Better Product',
        'advance_features': 'Advance Features',
        'others': 'Others'
    };
    return reasonMap[reason] || reason;
}

function formatwinReason(reason) {
    const reasonMap = {
        'good_value': 'Good value of money',
        'bestproduct': 'Best Product',
        'advanced_features': 'Advanced features',
        'others': 'Others'
    };
    return reasonMap[reason] || reason;
}

function getMonthlyProgressData() {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const currentYear = new Date().getFullYear();
    const stats = {};
    monthNames.forEach(m => stats[m]={total:0,completed:0});

    evaluationData.forEach(e=>{
        const date = new Date(e.date);
        if(date.getFullYear()===currentYear){
            const m = monthNames[date.getMonth()];
            stats[m].total++;
            if(e.status==='complete') stats[m].completed++;
        }
    });

    return { labels:monthNames, completed:monthNames.map(m=>stats[m].completed), total:monthNames.map(m=>stats[m].total) };
}

function populateEvaluationList() {
    const listContainer = document.getElementById('evaluationList');
    if (!listContainer) return;

    const recentEvaluations = evaluationData
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 8);

    if (recentEvaluations.length === 0) {
        listContainer.innerHTML = '<div class="empty-state">No evaluations found</div>';
        return;
    }

    listContainer.innerHTML = recentEvaluations.map(e => {
        const getStatusColor = (status) => {
            if (status === 'complete') return '#28a745';
            if (status === 'progress') return '#ffc107';
            return '#dc3545';
        };

        return `
            <div class="evaluation-item">
                <div class="evaluation-info">
                    <div class="evaluation-product">${e.product}</div>
                    <div class="evaluation-details">
                        üë§ ${e.staff} ‚Ä¢ üè¢ ${e.customerCompany} ‚Ä¢ üìç ${e.customerLocation} ‚Ä¢ üìÖ ${e.date}
                    </div>
                    <div class="form-progress" style="margin-top:4px;">
                        <small>
                            <span style="color: ${getStatusColor(e.pre_eval)}; font-weight: 500;">Pre-evaluation</span> | 
                            <span style="color: ${getStatusColor(e.eval)}; font-weight: 500;">Evaluation</span> | 
                            <span style="color: ${getStatusColor(e.post_eval)}; font-weight: 500;">Post-evaluation</span>
                        </small>
                    </div>
                </div>
                <div class="evaluation-status">
                    <span class="status-badge" style="background:${getStatusColor(e.status)};">
                        ${e.status === 'complete' ? '‚úÖ Complete' : e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft'}
                    </span>
                </div>
            </div>
        `;
    }).join('');
}

function initMap() {
    if(map) map.remove();
    
    map = L.map('map').setView([4.2105, 101.9758], 6);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);
    markerClusterGroup = L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });
    
    map.addLayer(markerClusterGroup);
}

function updateMapMarkers() {
    if (!map || !markerClusterGroup) return;

    markerClusterGroup.clearLayers();
    
    const data = getFilteredData();
    let displayedCount = 0;

    console.log(`\nüó∫Ô∏è Updating map with ${data.length} evaluations...`);

    data.forEach((e, index) => {
        if (e.location && Array.isArray(e.location) && e.location.length === 2) {
            const color = e.status === 'complete' ? '#28a745' : 
                         e.status === 'progress' ? '#ffc107' : '#dc3545';

            const icon = L.divIcon({
                className: 'custom-marker-icon',
                html: `<div style="
                    width: 24px;
                    height: 24px;
                    background: ${color};
                    border: 3px solid white;
                    border-radius: 50%;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.4);
                "></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker(e.location, { icon });

            const isClickable = e.status !== 'complete';
            const statusText = e.status === 'complete' ? '‚úÖ Complete' : 
                            e.status === 'progress' ? '‚è≥ In Progress' : 'üìù Draft';
            const statusBadge = isClickable 
                ? `<a href="detail.html?id=${e.id}" style="
                    display: inline-block;
                    padding: 8px 16px;
                    background: ${color};
                    color: white;
                    border-radius: 6px;
                    font-size: 13px;
                    font-weight: bold;
                    text-transform: uppercase;
                    text-decoration: none;
                    cursor: pointer;
                    transition: all 0.2s ease;
                " onmouseover="this.style.opacity='0.8'; this.style.transform='scale(1.05)';" 
                onmouseout="this.style.opacity='1'; this.style.transform='scale(1)';">
                    ${statusText} ‚Üí
                </a>`
                : `<span style="
                    display: inline-block;
                    padding: 8px 16px;
                    background: ${color};
                    color: white;
                    border-radius: 6px;
                    font-size: 13px;
                    font-weight: bold;
                    text-transform: uppercase;
                ">
                    ${statusText}
                </span>`;
    
            const popupContent = `
                <div style="min-width: 260px; font-family: Arial, sans-serif;">
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 12px; color: #333; border-bottom: 3px solid ${color}; padding-bottom: 8px;">
                        ${e.product}
                    </div>
                    <div style="font-size: 13px; line-height: 2; color: #555;">
                        <div><strong>üì¶ Category:</strong> ${e.category}</div>
                        <div><strong>üë§ Staff:</strong> ${e.staff}</div>
                        <div><strong>üè¢ Company:</strong> ${e.customerCompany}</div>
                        <div><strong>üìç Location:</strong> ${e.customerLocation}</div>
                        <div><strong>üìÖ Date:</strong> ${e.date}</div>
                        ${e.searchQuery ? `<div style="font-size: 11px; color: #999; margin-top: 8px;"><em>Found via: "${e.searchQuery}"</em></div>` : ''}
                    </div>
                    <div style=
                        "margin-top: 12px; 
                        padding-top: 12px; 
                        border-top: 1px solid #eee; 
                        text-align: center;">
                        
                        ${statusBadge}
                        ${isClickable ? 
                        
                        `<div style=
                        "font-size: 11px; 
                        color: #666; 
                        margin-top: 6px;"> 
                        Click to view details
                        </div>` : ''}
                    </div>
                </div>
            `;

            marker.bindPopup(popupContent);
            markerClusterGroup.addLayer(marker);
            displayedCount++;

            console.log(`  ‚úì Marker ${index + 1}: ${e.customerCompany} at [${e.location[0].toFixed(4)}, ${e.location[1].toFixed(4)}]`);
        } else {
            console.warn(`  ‚úó No location: ${e.customerCompany} - ${e.customerLocation}`);
        }
    });
    if (displayedCount > 0) {
        const group = markerClusterGroup.getBounds();
        if (group.isValid()) {
            map.fitBounds(group, {
                padding: [50, 50],
                maxZoom: 13
            });
        }
    }

    console.log(`‚úÖ ${displayedCount} markers displayed on map\n`);
}

function getFilteredData() {
    const locationFilter = document.getElementById('locationFilter')?.value || 'all';
    const productFilter = document.getElementById('productFilter')?.value || 'all';

    const start = document.getElementById("startDate").value 
        ? new Date(document.getElementById("startDate").value) 
        : null;

    const end = document.getElementById("endDate").value 
        ? new Date(document.getElementById("endDate").value) 
        : null;

    return evaluationData.filter(e => {
        if (locationFilter !== 'all' && e.status !== locationFilter) return false;
        if (productFilter !== 'all' && e.category !== productFilter) return false;
        const d = new Date(e.date);
        if (start && d < start) return false;
        if (end) {
            const endCopy = new Date(end);
            endCopy.setHours(23, 59, 59, 999);
            if (d > endCopy) return false;
        }
        return true;
    });
}

function applyFilters() {
    updateMapMarkers();
}

function setupRealTimeUpdates() {
    client.subscribe(`databases.${databaseId}.collections.${collectionId}.documents`, () => {
        console.log('üì° Real-time update received');
        loadEvaluations();
    });
}

document.addEventListener('DOMContentLoaded', async () => {
    const user = await checkSession();
    if (user) {
        await loadEvaluations();
        setupRealTimeUpdates();
        document.getElementById('locationFilter').addEventListener('change', applyFilters);
        document.getElementById('productFilter').addEventListener('change', applyFilters);
        document.getElementById('startDate').addEventListener('change', applyFilters);
        document.getElementById('endDate').addEventListener('change', applyFilters);
    }
});
</script>

<footer class="footer">
<span>¬© 2025 ViTrox. All rights reserved.</span>
</footer>

</body>
</html>



